<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Sharing - Browser Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px;
        }
        .container { 
            max-width: 1000px; margin: 0 auto; 
            background: white; border-radius: 12px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1); overflow: hidden;
        }
        .header { 
            background: linear-gradient(90deg, #4f46e5, #7c3aed); 
            color: white; padding: 20px; text-align: center;
        }
        .status { 
            display: flex; align-items: center; gap: 10px; 
            justify-content: center; margin-top: 10px;
        }
        .indicator { 
            width: 12px; height: 12px; border-radius: 50%; 
            background: #ef4444;
        }
        .indicator.connected { background: #10b981; box-shadow: 0 0 10px rgba(16,185,129,0.5); }
        .main { display: flex; gap: 20px; padding: 20px; }
        .panel { 
            background: #f8fafc; border-radius: 8px; 
            padding: 20px; border: 1px solid #e2e8f0;
        }
        .session-panel { width: 300px; }
        .file-panel { flex: 1; }
        .btn {
            width: 100%; padding: 12px; margin: 8px 0; 
            border: none; border-radius: 6px; cursor: pointer;
            font-weight: 500; transition: all 0.2s;
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-primary { background: #4f46e5; color: white; }
        .btn-success { background: #10b981; color: white; }
        .token-display { 
            background: white; border: 2px solid #4f46e5; 
            border-radius: 6px; padding: 15px; margin: 10px 0;
            word-break: break-all; font-family: monospace; font-size: 12px;
        }
        .file-input { 
            border: 2px dashed #d1d5db; border-radius: 8px; 
            padding: 40px; text-align: center; margin: 10px 0;
            cursor: pointer; transition: all 0.3s;
        }
        .file-input:hover { border-color: #4f46e5; background: #f0f0ff; }
        .file-list { 
            max-height: 200px; overflow-y: auto; 
            border: 1px solid #e5e7eb; border-radius: 6px; margin: 10px 0;
        }
        .file-item { 
            display: flex; justify-content: space-between; 
            align-items: center; padding: 10px; border-bottom: 1px solid #f1f5f9;
        }
        .file-item:last-child { border-bottom: none; }
        .progress { 
            width: 100%; height: 8px; background: #e5e7eb; 
            border-radius: 4px; margin: 10px 0; overflow: hidden;
        }
        .progress-fill { 
            height: 100%; background: linear-gradient(90deg, #4f46e5, #7c3aed); 
            width: 0%; transition: width 0.3s;
        }
        .hidden { display: none !important; }
        .log { 
            background: #1f2937; color: #10b981; padding: 15px; 
            border-radius: 6px; font-family: monospace; font-size: 12px;
            max-height: 150px; overflow-y: auto; margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üîê P2P File Sharing - Browser Test</h1>
            <div class="status">
                <span id="status-indicator" class="indicator"></span>
                <span id="status-text">Disconnected</span>
            </div>
        </div>

        <div class="main">
            <!-- Session Panel -->
            <div class="panel session-panel">
                <h3>Session Control</h3>
                
                <button id="create-btn" class="btn btn-primary">Create Session</button>
                <button id="join-btn" class="btn btn-primary">Join Session</button>
                
                <!-- Token Display -->
                <div id="token-section" class="hidden">
                    <h4>Share this token:</h4>
                    <div id="token-display" class="token-display"></div>
                    <button id="copy-btn" class="btn">Copy Token</button>
                </div>
                
                <!-- Token Input -->
                <div id="join-section" class="hidden">
                    <h4>Enter Session Token:</h4>
                    <input type="text" id="token-input" placeholder="Paste token here..." 
                           style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #d1d5db; border-radius: 4px;">
                    <button id="connect-btn" class="btn btn-primary">Connect</button>
                    <button id="cancel-btn" class="btn">Cancel</button>
                </div>

                <!-- Encryption Status -->
                <div style="margin-top: 20px; text-align: center;">
                    <span id="encryption-icon">üîÑ</span>
                    <span id="encryption-text">Preparing...</span>
                </div>
            </div>

            <!-- File Transfer Panel -->
            <div class="panel file-panel">
                <h3>File Transfer</h3>
                
                <!-- File Selection -->
                <div id="file-input-zone" class="file-input">
                    <div>üìÅ</div>
                    <h4>Drop files here or click to select</h4>
                    <p>Select files to send securely</p>
                    <input type="file" id="file-input" multiple style="display: none;">
                </div>
                
                <!-- Selected Files -->
                <div id="selected-files" class="file-list hidden"></div>
                
                <button id="send-btn" class="btn btn-success" disabled>Send Files</button>
                
                <!-- Progress -->
                <div id="progress-section" class="hidden">
                    <div class="progress">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text" style="text-align: center;">0%</div>
                </div>
                
                <!-- Received Files -->
                <div>
                    <h4>Received Files</h4>
                    <div id="received-files" class="file-list">
                        <div style="padding: 20px; text-align: center; color: #6b7280;">
                            No files received yet
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Debug Log -->
        <div class="panel" style="margin: 20px;">
            <h4>Debug Log</h4>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        // Complete P2P File Sharing Implementation
        class P2PBrowserTest {
            constructor() {
                this.ws = null;
                this.wsUrl = 'wss://p2p-server-jgqj.onrender.com/ws'; // YOUR EXISTING SERVER
                this.keyPair = null;
                this.sharedKey = null;
                this.isEncryptionReady = false;
                this.selectedFiles = [];
                this.receivedFiles = [];
                
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.log('üöÄ P2P Browser Test initialized');
                this.log(`üåê Using server: ${this.wsUrl}`);
            }
            
            bindEvents() {
                // Session controls
                document.getElementById('create-btn').onclick = () => this.createSession();
                document.getElementById('join-btn').onclick = () => this.showJoinInput();
                document.getElementById('connect-btn').onclick = () => this.joinSession();
                document.getElementById('cancel-btn').onclick = () => this.hideJoinInput();
                document.getElementById('copy-btn').onclick = () => this.copyToken();
                
                // File operations
                document.getElementById('file-input-zone').onclick = () => {
                    document.getElementById('file-input').click();
                };
                document.getElementById('file-input').onchange = (e) => {
                    this.handleFileSelect(Array.from(e.target.files));
                };
                document.getElementById('send-btn').onclick = () => this.sendFiles();
                
                // Drag and drop
                const zone = document.getElementById('file-input-zone');
                zone.ondragover = (e) => { e.preventDefault(); zone.style.background = '#f0f0ff'; };
                zone.ondragleave = () => { zone.style.background = ''; };
                zone.ondrop = (e) => {
                    e.preventDefault();
                    zone.style.background = '';
                    this.handleFileSelect(Array.from(e.dataTransfer.files));
                };
            }
            
            async createSession() {
                try {
                    this.log('üéØ Creating session...');
                    await this.connectWebSocket();
                    this.sendMessage({
                        type: 'CREATE_INVITATION',
                        expires_in_minutes: 30,
                        intent: 'send_files',
                        capabilities: ['file_send', 'encryption']
                    });
                } catch (error) {
                    this.log('‚ùå Failed to create session: ' + error.message);
                }
            }
            
            async joinSession() {
                const token = document.getElementById('token-input').value.trim();
                if (!token) {
                    alert('Please enter a session token');
                    return;
                }
                
                try {
                    this.log('üéØ Joining session...');
                    await this.connectWebSocket();
                    this.sendMessage({
                        type: 'JOIN_BY_TOKEN',
                        token: token,
                        intent: 'receive_files',
                        capabilities: ['file_receive', 'encryption']
                    });
                } catch (error) {
                    this.log('‚ùå Failed to join session: ' + error.message);
                }
            }
            
            connectWebSocket() {
                return new Promise((resolve, reject) => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        resolve();
                        return;
                    }
                    
                    this.updateStatus('Connecting...');
                    this.ws = new WebSocket(this.wsUrl);
                    
                    const timeout = setTimeout(() => reject(new Error('Connection timeout')), 10000);
                    
                    this.ws.onopen = () => {
                        clearTimeout(timeout);
                        this.log('‚úÖ Connected to P2P server');
                        this.updateStatus('Connected');
                        resolve();
                    };
                    
                    this.ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.log(`üì® Received: ${message.type}`);
                        this.handleMessage(message);
                    };
                    
                    this.ws.onerror = (error) => {
                        clearTimeout(timeout);
                        this.log('‚ùå WebSocket error');
                        this.updateStatus('Error');
                        reject(error);
                    };
                    
                    this.ws.onclose = () => {
                        this.log('üîå Disconnected');
                        this.updateStatus('Disconnected');
                    };
                });
            }
            
            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    this.log(`üì§ Sent: ${message.type}`);
                    return true;
                }
                return false;
            }
            
            async handleMessage(message) {
                switch (message.type) {
                    case 'INVITATION_CREATED':
                        this.log('üé´ Session created: ' + message.session_id);
                        this.showToken(message.token);
                        await this.setupEncryption();
                        break;
                        
                    case 'JOINED_SESSION':
                        this.log('‚úÖ Joined session: ' + message.session_id);
                        this.hideJoinInput();
                        await this.setupEncryption();
                        break;
                        
                    case 'KEY_EXCHANGE':
                        this.log('üîë Received peer public key');
                        await this.handleKeyExchange(message);
                        break;
                        
                    case 'ENCRYPTED_MESSAGE':
                        this.log('üì® Received encrypted file');
                        await this.handleEncryptedMessage(message);
                        break;
                        
                    default:
                        this.log('‚ùì Unknown message: ' + message.type);
                }
            }
            
            async setupEncryption() {
                try {
                    this.log('üîê Setting up encryption...');
                    this.updateEncryptionStatus('üîÑ', 'Generating keys...');
                    
                    // Generate ECDH key pair
                    this.keyPair = await crypto.subtle.generateKey(
                        { name: 'ECDH', namedCurve: 'P-256' },
                        true,
                        ['deriveKey', 'deriveBits']
                    );
                    
                    // Export public key
                    const publicKeyBuffer = await crypto.subtle.exportKey('raw', this.keyPair.publicKey);
                    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
                    
                    // Send public key
                    this.sendMessage({
                        type: 'KEY_EXCHANGE',
                        public_key: Array.from(publicKeyBytes),
                        party: 'web',
                        algorithm: 'ECDH-P256'
                    });
                    
                    this.updateEncryptionStatus('üîë', 'Exchanging keys...');
                    
                    // Auto-ready for single user testing
                    setTimeout(() => {
                        if (!this.isEncryptionReady) {
                            this.onEncryptionReady();
                        }
                    }, 3000);
                    
                } catch (error) {
                    this.log('‚ùå Encryption setup failed: ' + error.message);
                    this.updateEncryptionStatus('‚ö†Ô∏è', 'Encryption error');
                }
            }
            
            async handleKeyExchange(message) {
                try {
                    // Import peer's public key
                    const peerKeyArray = new Uint8Array(message.public_key);
                    const peerPublicKey = await crypto.subtle.importKey(
                        'raw', peerKeyArray,
                        { name: 'ECDH', namedCurve: 'P-256' },
                        false, []
                    );
                    
                    // Derive shared secret
                    this.sharedKey = await crypto.subtle.deriveKey(
                        { name: 'ECDH', public: peerPublicKey },
                        this.keyPair.privateKey,
                        { name: 'AES-GCM', length: 256 },
                        false, ['encrypt', 'decrypt']
                    );
                    
                    this.onEncryptionReady();
                    
                } catch (error) {
                    this.log('‚ùå Key exchange failed: ' + error.message);
                }
            }
            
            onEncryptionReady() {
                this.isEncryptionReady = true;
                this.log('‚úÖ Encryption ready!');
                this.updateEncryptionStatus('üîí', 'End-to-end encrypted');
                document.getElementById('send-btn').disabled = false;
            }
            
            handleFileSelect(files) {
                this.selectedFiles = files;
                this.log(`üìÅ Selected ${files.length} file(s)`);
                this.updateFileList();
            }
            
            updateFileList() {
                const container = document.getElementById('selected-files');
                
                if (this.selectedFiles.length > 0) {
                    container.classList.remove('hidden');
                    container.innerHTML = this.selectedFiles.map((file, index) => `
                        <div class="file-item">
                            <div>
                                <strong>${file.name}</strong><br>
                                <small>${this.formatFileSize(file.size)}</small>
                            </div>
                            <button onclick="app.removeFile(${index})" style="background: none; border: none; color: #ef4444; cursor: pointer;">‚ùå</button>
                        </div>
                    `).join('');
                } else {
                    container.classList.add('hidden');
                }
            }
            
            removeFile(index) {
                this.selectedFiles.splice(index, 1);
                this.updateFileList();
            }
            
            async sendFiles() {
                if (!this.isEncryptionReady) {
                    alert('Encryption not ready. Please wait...');
                    return;
                }
                
                if (this.selectedFiles.length === 0) {
                    alert('No files selected.');
                    return;
                }
                
                this.log(`üì§ Sending ${this.selectedFiles.length} file(s)...`);
                document.getElementById('progress-section').classList.remove('hidden');
                document.getElementById('send-btn').disabled = true;
                
                try {
                    for (let i = 0; i < this.selectedFiles.length; i++) {
                        const file = this.selectedFiles[i];
                        
                        // Read file
                        const arrayBuffer = await file.arrayBuffer();
                        const fileData = new Uint8Array(arrayBuffer);
                        
                        // Prepare payload
                        const payload = {
                            filename: file.name,
                            data: Array.from(fileData),
                            size: file.size,
                            type: 'FILE_DATA'
                        };
                        
                        // Encrypt
                        const encrypted = await this.encryptData(payload);
                        
                        // Send
                        this.sendMessage({
                            type: 'ENCRYPTED_MESSAGE',
                            encrypted_payload: encrypted,
                            message_type: 'FILE_DATA',
                            encryption_algorithm: 'AES-256-GCM'
                        });
                        
                        // Update progress
                        const progress = ((i + 1) / this.selectedFiles.length) * 100;
                        this.updateProgress(progress);
                        
                        this.log(`‚úÖ Sent: ${file.name}`);
                    }
                    
                    this.log('üéâ All files sent successfully!');
                    
                } catch (error) {
                    this.log('‚ùå Send failed: ' + error.message);
                } finally {
                    document.getElementById('send-btn').disabled = false;
                    setTimeout(() => {
                        document.getElementById('progress-section').classList.add('hidden');
                        this.updateProgress(0);
                    }, 2000);
                }
            }
            
            async handleEncryptedMessage(message) {
                try {
                    const decrypted = await this.decryptData(message.encrypted_payload);
                    
                    if (decrypted.type === 'FILE_DATA') {
                        this.log(`üìÅ Received: ${decrypted.filename}`);
                        
                        // Create download
                        const blob = new Blob([new Uint8Array(decrypted.data)]);
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = decrypted.filename;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Update UI
                        this.receivedFiles.push({
                            name: decrypted.filename,
                            size: decrypted.size,
                            time: new Date().toLocaleTimeString()
                        });
                        this.updateReceivedList();
                        
                        this.log(`‚úÖ Downloaded: ${decrypted.filename}`);
                    }
                } catch (error) {
                    this.log('‚ùå Decrypt failed: ' + error.message);
                }
            }
            
            async encryptData(data) {
                const encoder = new TextEncoder();
                const dataBytes = encoder.encode(JSON.stringify(data));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    this.sharedKey,
                    dataBytes
                );
                
                return {
                    iv: Array.from(iv),
                    data: Array.from(new Uint8Array(encrypted))
                };
            }
            
            async decryptData(encryptedData) {
                const iv = new Uint8Array(encryptedData.iv);
                const ciphertext = new Uint8Array(encryptedData.data);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv },
                    this.sharedKey,
                    ciphertext
                );
                
                const decoder = new TextDecoder();
                return JSON.parse(decoder.decode(decrypted));
            }
            
            updateReceivedList() {
                const container = document.getElementById('received-files');
                
                if (this.receivedFiles.length > 0) {
                    container.innerHTML = this.receivedFiles.map(file => `
                        <div class="file-item">
                            <div>
                                <strong>${file.name}</strong><br>
                                <small>${this.formatFileSize(file.size)} - ${file.time}</small>
                            </div>
                            <span style="color: #10b981;">‚úÖ</span>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">No files received yet</div>';
                }
            }
            
            // UI Helper Methods
            updateStatus(status) {
                const indicator = document.getElementById('status-indicator');
                const text = document.getElementById('status-text');
                
                text.textContent = status;
                
                if (status === 'Connected') {
                    indicator.classList.add('connected');
                } else {
                    indicator.classList.remove('connected');
                }
            }
            
            updateEncryptionStatus(icon, text) {
                document.getElementById('encryption-icon').textContent = icon;
                document.getElementById('encryption-text').textContent = text;
            }
            
            showToken(token) {
                document.getElementById('token-section').classList.remove('hidden');
                document.getElementById('token-display').textContent = token;
            }
            
            showJoinInput() {
                document.getElementById('join-section').classList.remove('hidden');
                document.getElementById('token-input').focus();
            }
            
            hideJoinInput() {
                document.getElementById('join-section').classList.add('hidden');
                document.getElementById('token-input').value = '';
            }
            
            copyToken() {
                const token = document.getElementById('token-display').textContent;
                navigator.clipboard.writeText(token).then(() => {
                    const btn = document.getElementById('copy-btn');
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = 'Copy Token', 2000);
                });
            }
            
            updateProgress(percent) {
                document.getElementById('progress-fill').style.width = percent + '%';
                document.getElementById('progress-text').textContent = Math.round(percent) + '%';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            log(message) {
                const log = document.getElementById('log');
                const time = new Date().toLocaleTimeString();
                log.innerHTML += `<div>[${time}] ${message}</div>`;
                log.scrollTop = log.scrollHeight;
            }
        }
        
        // Initialize app
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new P2PBrowserTest();
        });
    </script>
</body>
</html>
